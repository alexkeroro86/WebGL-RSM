<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>WebGL - RSM</title>

    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0px;
            padding: 0px;
            border: 0px;
            overflow: hidden;
        }
        .navbar {
            z-index: 999;
        }
    </style>
</head>
<body>
    <script type='x-shader/x-vertex' id='gbuffer-vs'>
        #version 300 es

        layout(location = 0) in vec3 iPosition;
        layout(location = 1) in vec2 iTexcoord;
        layout(location = 2) in vec3 iNormal;

        out vec2 vTexcoord;
        out vec3 vNormal;
        out vec4 vPosW;

        uniform mat4 uMVP;
        uniform mat4 uM;

        void main() {
            vTexcoord = iTexcoord;
            vNormal = mat3(transpose(inverse(uM))) * iNormal;
            vPosW = uM * vec4(iPosition, 1.0f);
            
            gl_Position = uMVP * vec4(iPosition, 1.0f);
            vPosW.w = gl_Position.z; // depth in clip space for CSM
        }
    </script>
    <script type='x-shader/x-fragment' id='gbuffer-fs'>
        #version 300 es
        precision highp float;

        layout(location = 0) out vec4 fFragPosW;
        layout(location = 1) out vec4 fFragColor;
        layout(location = 2) out vec4 fFragNormal;

        in vec2 vTexcoord;
        in vec3 vNormal;
        in vec4 vPosW;

        uniform sampler2D uMapKd;
        uniform float uUseTech;

        void main() {
            fFragColor = texture(uMapKd, vTexcoord);
            if (fFragColor.a < 0.5f) {
                discard;
            }
            fFragPosW = vPosW;
            fFragNormal = vec4(normalize(vNormal), uUseTech);
        }
    </script>

    <script type='x-shader/x-vertex' id='deferred-vs'>
        #version 300 es

        layout(location = 0) in vec2 iPosition;
        layout(location = 1) in vec2 iTexcoord;

        out vec2 vTexcoord;

        void main() {
            vTexcoord = iTexcoord;
            gl_Position = vec4(iPosition, 0.0f, 1.0f);
        }
    </script>
    <script type='x-shader/x-fragment' id='deferred-fs'>
        #version 300 es
        precision highp float;

        out vec4 fFragColor;

        in vec2 vTexcoord;

        const int NUM_CSM = 3;

        uniform sampler2D uCamMapPosW;
        uniform sampler2D uCamMapColor;
        uniform sampler2D uCamMapNormal;
        uniform sampler2D uCamMapDepth;
        uniform sampler2D uLitMapDepth;  // shadow mapping
        uniform sampler2D uLitMapPosW;
        uniform sampler2D uLitMapColor;
        uniform sampler2D uLitMapNormal;
        uniform sampler2D uLitCmapDepth[NUM_CSM];
        uniform vec3 uEye;
        uniform vec3 uLight;
        uniform mat4 uLitMatVP;  // shadow mapping
        uniform float uCamCrange[NUM_CSM];
        uniform mat4 uLitCmatVP[NUM_CSM];

        uniform int uUseRSM;
        uniform int uUseCSM;
        uniform int uVisualCSM;
        uniform int uVisualTech;
        uniform int uVisualCamMapDepth;

        const float PI = 3.1415926f;

        float checkShadow(vec4 posL, vec3 Nn, vec3 Ln) {
            vec3 projCoord = posL.xyz / posL.w;
            if (projCoord.z > 1.f) {
                return 0.0f;
            }
            projCoord = projCoord * 0.5f + 0.5f;

            // from camera view
            float currDepth = projCoord.z;
            // from light view
            float occDepth = texture(uLitMapDepth, projCoord.xy).r;
            
            // adaptive bias
            float bias = 0.005f * tan(acos(dot(Nn, Ln)));
            bias = clamp(bias, 0.f, 0.01f);

            if (occDepth < currDepth - bias) {
                return 0.5f;
            }
            else {
                return 1.0f;
            }
        }
        float checkCascadedShadow(int i, vec4 posL, vec3 Nn, vec3 Ln) {
            vec3 projCoord = posL.xyz / posL.w;
            if (projCoord.z > 1.f) {
                return 1.0f;
            }
            projCoord = projCoord * 0.5f + 0.5f;

            // from camera view
            float currDepth = projCoord.z;
            // from light view
            float occDepth = texture(uLitCmapDepth[i], projCoord.xy).r;
            
            // adaptive bias
            float bias = 0.005f * tan(acos(dot(Nn, Ln)));
            bias = clamp(bias, 0.f, 0.01f);

            if (occDepth < currDepth - bias) {
                return 0.5f;
            }
            else {
                return 1.0f;
            }
        }

        float RAND1(vec2 x) {
            uint n = floatBitsToUint(x.y * 214013.f + x.x * 2531011.f);
            n = n * (n * n * 15731u + 789221u);
            n = (n >> 9u) | 0x3F800000u;
            return 2.f - uintBitsToFloat(n);
        }
        vec3 RSM(vec3 posW, vec4 posL, vec3 Nn) {
            vec3 projCoord = posL.xyz / posL.w;
            if (projCoord.z > 1.f) {
                return vec3(0.f, 0.f, 0.f);
            }
            vec2 litUV = projCoord.xy * 0.5f + 0.5f;

            const float RADIUS = 0.01f;
            const float INTENSITY = 100.0f;
            const int SAMPLE = 64;

            vec3 color = vec3(0.f, 0.f, 0.f);
            vec2 seed = vec2(posW.x + posW.y, posW.y + posW.z);
            float xi1 = 0.f;
            float xi2 = 0.f;
            for (int i = 0; i < SAMPLE; ++i) {
                xi1 = RAND1(seed + vec2(i + 1, i));
                xi2 = RAND1(seed + vec2(i, i + 1));

                vec2 sampleUV = litUV + RADIUS * vec2(xi1 * sin(2.f * PI * xi2), xi1 * cos(2.f * PI * xi2));
                vec3 litPhi = texture(uLitMapColor, sampleUV).rgb;
                vec3 litPosW = texture(uLitMapPosW, sampleUV).rgb;
                vec3 litNormal = texture(uLitMapNormal, sampleUV).rgb;
                float useTech = texture(uLitMapNormal, sampleUV).a;
                // ignore non-specified pixel light object
                if (useTech < 0.5f) {
                    continue;
                }

                vec3 L = posW - litPosW;
                vec3 Ln = normalize(L);
                color += (xi1 * xi2) * litPhi * max(0.f, dot(litNormal, Ln)) * max(0.f, dot(Nn, -Ln)) / pow(length(L), 2.f);
            }

            return color * INTENSITY;
        }

        void main() {
            ivec2 fragCoord = ivec2(gl_FragCoord.xy);

            vec4 albedo = texelFetch(uCamMapColor, fragCoord, 0);
            vec3 posW = texelFetch(uCamMapPosW, fragCoord, 0).rgb;
            vec4 posL = uLitMatVP * vec4(posW, 1.0f);
            vec3 Nn = texelFetch(uCamMapNormal, fragCoord, 0).rgb;

            vec3 Vn = normalize(uEye - posW);
            vec3 Ln = normalize(uLight);
            vec3 Hn = normalize(Ln + Vn);

            float shadowFactor = 1.f;
            vec4 cascadedIndicator = vec4(0.f, 0.f, 0.f, 0.f);
            // shadow
            if (uUseCSM == 0) {
                shadowFactor = checkShadow(posL, Nn, Ln);
            }
            // cascaded shadow
            else {
                // choose LOD for CSM in clip space
                for (int i = 0; i < NUM_CSM; ++i) {
                    float fogDepth = texelFetch(uCamMapPosW, fragCoord, 0).a;
                    if (fogDepth <= uCamCrange[i]) {
                        vec4 posCl = uLitCmatVP[i] * vec4(posW, 1.f);
                        shadowFactor = checkCascadedShadow(i, posCl, Nn, Ln);

                        // visualize frustum sections
                        if (uVisualCSM == 0) {
                            cascadedIndicator = vec4(0.f, 0.f, 0.f, 0.f);
                        }
                        else if (i == 0) {
                            cascadedIndicator = vec4(0.05f, 0.f, 0.f, 0.f);
                        }
                        else if (i == 1) {
                            cascadedIndicator = vec4(0.f, 0.05f, 0.f, 0.f);
                        }
                        else if (i == 2) {
                            cascadedIndicator = vec4(0.f, 0.f, 0.05f, 0.f);
                        }

                        break;
                    }
                }
            }

            // reflective shadow map
            vec3 rsm = vec3(0.f, 0.f, 0.f);
            if (uUseRSM == 1) {
                rsm = RSM(posW, posL, Nn);
            }

            // blinn-phong
            vec3 ambient = vec3(0.01f, 0.01f, 0.01f) + rsm;
            vec3 diffuse = max(dot(Nn, Ln), 0.f) * albedo.rgb;
            vec3 specular = pow(max(dot(Nn, Hn), 0.f), 20.0f) * vec3(0.0f, 0.0f, 0.0f);

            fFragColor = cascadedIndicator + vec4(ambient + shadowFactor * (diffuse + specular), 1.0f);

            // visualize depth
            if (uVisualCamMapDepth == 1) {
                float z = texelFetch(uCamMapDepth, fragCoord, 0).r;
                z = (2.0f * 0.1f) / (1800.0f + 0.1f - z * (1800.0f - 0.1f));
                fFragColor = vec4(z, z, z, 1.0f);
            }
            // visualize tech channel
            if (uVisualTech == 1) {
                fFragColor = vec4(texelFetch(uCamMapNormal, fragCoord, 0).a, 0.f, 0.f, 1.0f);
            }
            // float z = texture(uLitCmapDepth[0], vTexcoord).r;
            // fFragColor = vec4(z, z, z, 1.f);
        }
    </script>

    <script type='x-shader/x-vertex' id='blinn-phong-vs'>
        #version 300 es

        layout(location = 0) in vec3 iPosition;
        layout(location = 1) in vec2 iTexcoord;
        layout(location = 2) in vec3 iNormal;

        out vec2 vTexcoord;
        out vec3 vNormal;
        out vec3 vPosW;

        uniform mat4 uMVP;
        uniform mat4 uM;

        void main() {
            vTexcoord = iTexcoord;
            vNormal = mat3(transpose(inverse(uM))) * iNormal;
            vPosW = vec3(uM * vec4(iPosition, 1.0f));

            gl_Position = uMVP * vec4(iPosition, 1.0f);
        }
    </script>
    <script type='x-shader/x-fragment' id='blinn-phong-fs'>
        #version 300 es
        precision highp float;

        out vec4 fFragColor;

        in vec2 vTexcoord;
        in vec3 vNormal;
        in vec3 vPosW;

        uniform sampler2D uMapKd;
        uniform vec3 uEye;

        void main() {
            vec3 Nn = normalize(vNormal);
            vec3 Vn = normalize(uEye - vPosW);
            vec3 Ln = normalize(vec3(1.0f, 1.0f, 1.0f));
            vec3 Hn = normalize(Ln + Vn);

            vec4 albedo = texture(uMapKd, vTexcoord);
            if (albedo.a == 0.0f) {
                discard;
            }

            vec3 ambient = vec3(0.01f, 0.01f, 0.01f);
            vec3 diffuse = max(dot(Nn, Ln), 0.f) * albedo.rgb;
            vec3 specular = pow(max(dot(Nn, Hn), 0.f), 20.0f) * vec3(0.0f, 0.0f, 0.0f);

            fFragColor = vec4(ambient + diffuse + specular, 1.0f);
        }
    </script>
    
    <script type="text/javascript" src="vendor.bundle.js"></script>
    <script type="text/javascript" src="main.bundle.js"></script>
</body>
</html>